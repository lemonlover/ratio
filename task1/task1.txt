
0. Если нужно реализовать функционал как можно быстрее, то попросил бы модуль 
   https://marketplace.1c-bitrix.ru/solutions/bestrank.bonus/ - подешевле
   https://marketplace.1c-bitrix.ru/solutions/vbcherepanov.bonus/#tab-log-link - подороже
   (если бы заказчик пошел на это :).

Ну а если реализовывать самому то. 

Часть 1. Начисляем бонусы на счет пользователю.

	0. Создаем в админке инфоблок с двумя свойствами X и Y (для простоты, хотя можно сделать и отдельную страницу админки под настройку данного функционала и использовать все что нам предоставляет битрикс в админке).

	1. Есть замечательные события - 
	OnSalePayOrder - Вызывается после изменения флага оплаты заказа. 
	OnSaleStatusOrder -Вызывается после изменения статуса заказа. 
	
	Воспользуемся вторым, так как оно вызывается позднее, когда статус 
	заказа уже стал "оплачен"
	привязываемся к нему где нибудь в init.php (например)
	непосредствено, отлавливаем там оплаченный заказ (его ID) с соотвествующим статусом

	2. Получаем сумму заказа по ID заказа, который пришел к нам в событие.  
	   
	3. Получаем активный на данный момент элемент инфоблока с акциями и его значение X
	
	4. Получаем по ID пользователя с использованием CSaleUserAccount::GetByUserID
	   значение счета пользователя, если он есть (и валюту пользователя тоже). 
	   4.1 если нет счета, то создаем.
	
	5. Считаем необходимый нам процент от заказа с учетом валюты пользователя.

	6. Складыеваем на счет оплатившего пользователя, прибавляя к текущему балансу	   
	   
	Ура! мы пополнили счет пользователю на сумму X процентов от заказа.

	
Часть 2. Оплачиваем заказ с внутреннего счета не более Y процентов
	
	0.0. Эту проблему также можно решить готовым решением 
	https://marketplace.1c-bitrix.ru/solutions/asd.paypart/, 
	но тогда Y будет фиксированной константой, что не соответсвует
	постановке данной задачию


	Тогда делаем следующее: 

	0. Модернезируем шаблоны всех стандартных компонентов так, чтобы 
	пользователь везде мог видеть процент покупки, который он может оплатить 
	с бонусного счета. А также модифицировать функционал так, чтобы пользователь
	мог видеть сколько конкретно (в пересчете в валюту) он сможет оплатить со 
	своего бонусного счета.

	0.1. Также необходимо предоставить возможность выбора (оплачивать данный заказ 
	бонусными балами или нет). на этапе корзины. 
	Можно сделать чек-бокс, исходя из значения которого установим параметр PAY_BY_BONUS
	c использованием COption

	1.В параметрах компонента bitrix:sale.order.full выставляем возможность оплаты с внутреенного счета. ALLOW_PAY_FROM_ACCOUNT => "Y"

	2. Воспользуемся событием OnSaleBeforePayOrder
	   вешаем на него обработчик в котором
	
		Если PAY_BY_BONUS активирован пользователем то

	   2.1 Получаем текущий Флаг оплаты
	   2.2 получаем ID заказа => необходимые свойства заказа
	   2.3 Получаем текущую акцию и непосредственно Y 
	   2.4 Вычисляем сумму заказа которую можно оплатить бонусами, относительно Y 
	   2.5 Пересчитываем сумму заказа с учетом бонусных балов и валюты пользователя
	   	 2.5.1 Если хватает бонусных балов и их количество не превышает Y%
	   	 то списываем со счета пользователя данное количество баллов, и 
	   	 прибавляем эти баллы к величине скидки. (так как оплата бонусами
	   	 по сути и является скидкой)
	   	 2.5.2. Иначе, генерируем исключение и отменяем оплату заказа 
	   	 при помощи смены значения флага оплаты на N, для текущего заказа
                       
	   	 Иначе ничего не делаем и просто оплачеваем заказ.

Ура! Мы оплатили заказ бонусными балами не больше Y, или не оплатили если их не хватает

Примечание!!!! 

OnSaleBeforePayOrder - вызывает сомнение использование этого события для пополнения бонусного счета пользоватля и непосрественно параметра bPay, так как в руководстве сказано следующее:

что если параметр bWithdraw установлен в true, то установка параметра bPay в true приведет к тому, что необходимая сумма денег будет внесена на счет покупателя перед оплатой,
, а установка в false приведет к тому, что оплата будет происходить целиком с внутреннего счета; 

Не использовал данный метод прежде, но если разобраться в нем и посмотреть в bxliveapi подробнее его функционирование, то можно решить и задачу пополнения и задачу списания 
балов используя обработчик только этого события.

